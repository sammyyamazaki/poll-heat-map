<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Import-Ansicht (Drag & Drop, Multi-Datei)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #map { height: 100%; }
    .controls {
      position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
      background: rgba(255,255,255,0.95); padding: 8px 10px; border-radius: 10px; z-index: 999;
      display: flex; gap: 10px; align-items: center; box-shadow: 0 2px 8px rgba(0,0,0,0.25);
      flex-wrap: wrap; max-width: 95vw;
    }
    .badge { font-size: 12px; background:#eee; padding:2px 6px; border-radius:999px; }
    select, button, input[type="file"] { padding: 6px; }
    .dropzone {
      position: absolute; left: 10px; top: 10px; z-index: 998;
      background: rgba(255,255,255,0.85); border: 2px dashed #9ca3af; border-radius: 10px;
      padding: 10px 12px; max-width: 260px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      transition: border-color .2s, background .2s;
    }
    .dropzone.highlight { border-color: #2563eb; background: rgba(219,234,254,0.9); }
    .filelist { font-size: 12px; margin-top: 6px; max-height: 120px; overflow:auto; }
    .filelist div { white-space: nowrap; text-overflow: ellipsis; overflow: hidden; }
    @media (max-width: 700px) {
      .controls { gap: 8px; }
      .dropzone { position: static; max-width: none; }
    }
  </style>
</head>
<body>
  <div class="controls">
    <label>Dateien laden:
      <input type="file" id="fileInput" accept=".geojson,.json,.csv,.kml,.gpx" multiple />
    </label>
    <label>Basemap:
      <select id="basemap">
        <option value="positron" selected>CartoDB Positron</option>
        <option value="voyager">CartoDB Voyager</option>
        <option value="osmde">OSM DE</option>
        <option value="osmstd">OSM Standard</option>
        <option value="tonerlite">Stamen Toner Lite</option>
      </select>
    </label>
    Ansicht:
    <label><input type="radio" name="mode" value="heat" checked> Heatmap</label>
    <label><input type="radio" name="mode" value="cluster"> Cluster</label>
    <label><input type="radio" name="mode" value="both"> Beides</label>
    <span class="badge" id="count">0 Pins</span>
    <button id="fitBtn">Fit to Pins</button>
  </div>

  <div class="dropzone" id="dropzone">
    <strong>Drag & Drop Import</strong><br/>
    GeoJSON / CSV / KML / GPX hierher ziehen<br/>
    <div class="filelist" id="filelist"></div>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script>
    const map = L.map('map').setView([51.4566, 7.0123], 12);

    // Basemaps
    const basemaps = {
      positron: L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; OpenStreetMap & CARTO', subdomains: 'abcd', maxZoom: 20 }),
      voyager:  L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', { attribution: '&copy; OpenStreetMap & CARTO', subdomains: 'abcd', maxZoom: 20 }),
      osmde:    L.tileLayer('https://tile.openstreetmap.de/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap', maxZoom: 19 }),
      osmstd:   L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap', maxZoom: 19 }),
      tonerlite:L.tileLayer('https://stamen-tiles.a.ssl.fastly.net/toner-lite/{z}/{x}/{y}.png', { attribution: '&copy; Stamen & OpenStreetMap', maxZoom: 20 })
    };
    let currentBase = basemaps.positron.addTo(map);
    document.getElementById('basemap').addEventListener('change', (e) => {
      const val = e.target.value;
      if (basemaps[val]) { map.removeLayer(currentBase); currentBase = basemaps[val].addTo(map); }
    });

    // Overlays
    const heat = L.heatLayer([], { radius: 40, blur: 25, maxZoom: 16, minOpacity: 0.3 });
    const clusters = L.markerClusterGroup({ showCoverageOnHover: false, maxClusterRadius: 60 });

    const pins = []; // {lat, lon, size}
    const countEl = document.getElementById('count');
    function updateCount() { countEl.textContent = pins.length + ' Pins'; }

    function pinToMarker(p) {
      const s = Math.max(1, Math.min(5, p.size || 2));
      return L.marker([p.lat, p.lon], {
        icon: L.divIcon({ className: 'pin',
          html: '<div style="width:'+ (s*6) +'px;height:'+ (s*6) +'px;border-radius:50%;border:2px solid #ef4444;background:rgba(239,68,68,0.5)"></div>',
          iconSize: [s*6, s*6], iconAnchor: [s*3, s*3] })
      });
    }

    function renderAll() {
      heat.setLatLngs(pins.map(p => [p.lat, p.lon, Math.max(1, Math.min(5, p.size))]));
      clusters.clearLayers();
      clusters.addLayers(pins.map(pinToMarker));
      applyMode(currentMode());
      updateCount();
    }

    function currentMode() { return document.querySelector('input[name="mode"]:checked').value; }
    function applyMode(mode) {
      map.removeLayer(heat);
      map.removeLayer(clusters);
      if (mode === 'heat') heat.addTo(map);
      else if (mode === 'cluster') clusters.addTo(map);
      else { heat.addTo(map); clusters.addTo(map); }
    }
    document.querySelectorAll('input[name="mode"]').forEach(r => r.addEventListener('change', () => applyMode(currentMode())));

    function fitToPins() {
      if (pins.length === 0) return;
      const latlngs = pins.map(p => [p.lat, p.lon]);
      map.fitBounds(latlngs, { padding: [40, 40] });
    }
    document.getElementById('fitBtn').addEventListener('click', fitToPins);

    // ---- Import handling ----
    document.getElementById('fileInput').addEventListener('change', (e) => {
      if (!e.target.files || !e.target.files.length) return;
      handleFiles(Array.from(e.target.files));
    });

    const dropzone = document.getElementById('dropzone');
    const filelist = document.getElementById('filelist');

    ['dragenter','dragover'].forEach(ev => dropzone.addEventListener(ev, (e) => {
      e.preventDefault(); e.stopPropagation(); dropzone.classList.add('highlight');
    }));
    ['dragleave','drop'].forEach(ev => dropzone.addEventListener(ev, (e) => {
      e.preventDefault(); e.stopPropagation(); dropzone.classList.remove('highlight');
    }));
    dropzone.addEventListener('drop', (e) => {
      const files = Array.from(e.dataTransfer.files || []);
      if (files.length) handleFiles(files);
    });

    async function handleFiles(files) {
      // Process sequentially to keep UI responsive & summarize
      for (const f of files) {
        const n = f.name;
        const ext = n.toLowerCase().split('.').pop();
        const text = await f.text();
        const before = pins.length;
        try {
          if (ext === 'geojson' || ext === 'json') importGeoJSON(JSON.parse(text));
          else if (ext === 'csv') importCSV(text);
          else if (ext === 'kml') importKML(text);
          else if (ext === 'gpx') importGPX(text);
          else continue;
          const added = pins.length - before;
          const item = document.createElement('div');
          item.textContent = `+${added} • ${n}`;
          filelist.appendChild(item);
        } catch (err) {
          console.error('Fehler beim Import', n, err);
          const item = document.createElement('div');
          item.textContent = `Fehler • ${n}`;
          filelist.appendChild(item);
        }
      }
      renderAll();
      fitToPins();
    }

    function addPin(lat, lon, size) {
      if (!isFinite(lat) || !isFinite(lon)) return;
      pins.push({ lat: +lat, lon: +lon, size: size ? +size : 2 });
    }

    // GeoJSON: FeatureCollection mit Point-Features; size in properties.size
    function importGeoJSON(geo) {
      if (!geo) return;
      if (geo.type === 'FeatureCollection' && Array.isArray(geo.features)) {
        geo.features.forEach(feat => {
          if (!feat || !feat.geometry) return;
          if (feat.geometry.type === 'Point') {
            const c = feat.geometry.coordinates; // [lon, lat]
            const size = feat.properties && feat.properties.size ? +feat.properties.size : 2;
            if (Array.isArray(c) && c.length >= 2) addPin(c[1], c[0], size);
          }
        });
      } else if (geo.type === 'Feature' && geo.geometry && geo.geometry.type === 'Point') {
        const c = geo.geometry.coordinates; const size = geo.properties?.size || 2;
        if (Array.isArray(c) && c.length >= 2) addPin(c[1], c[0], size);
      }
    }

    // CSV: lat,lon,size,timestamp (Header erwartet)
    function importCSV(text) {
      const lines = text.trim().split(/\r?\n/);
      if (lines.length < 2) return;
      const header = lines[0].split(',').map(h => h.trim().toLowerCase());
      const latIdx = header.indexOf('lat');
      const lonIdx = header.indexOf('lon');
      const sizeIdx = header.indexOf('size');
      if (latIdx < 0 || lonIdx < 0) return;
      for (let i = 1; i < lines.length; i++) {
        if (!lines[i].trim()) continue;
        const cols = lines[i].split(',').map(c => c.trim());
        const lat = parseFloat(cols[latIdx]);
        const lon = parseFloat(cols[lonIdx]);
        const size = sizeIdx >= 0 ? parseFloat(cols[sizeIdx]) : 2;
        addPin(lat, lon, size);
      }
    }

    // KML: Placemarks with Point/coordinates lon,lat,0 ; size in ExtendedData/Data[@name="size"]
    function importKML(xmlText) {
      const doc = new DOMParser().parseFromString(xmlText, 'text/xml');
      const placemarks = doc.getElementsByTagName('Placemark');
      for (const pm of placemarks) {
        const coordsNode = pm.getElementsByTagName('coordinates')[0];
        if (!coordsNode) continue;
        const parts = coordsNode.textContent.trim().split(',');
        const lon = parseFloat(parts[0]);
        const lat = parseFloat(parts[1]);
        let size = 2;
        const dataNodes = pm.getElementsByTagName('Data');
        for (const dn of dataNodes) {
          if (dn.getAttribute('name') === 'size') {
            const valNode = dn.getElementsByTagName('value')[0];
            if (valNode) size = parseFloat(valNode.textContent);
          }
        }
        addPin(lat, lon, size);
      }
    }

    // GPX: <wpt lat="" lon=""><name>size:3</name></wpt>
    function importGPX(xmlText) {
      const doc = new DOMParser().parseFromString(xmlText, 'text/xml');
      const wpts = doc.getElementsByTagName('wpt');
      for (const w of wpts) {
        const lat = parseFloat(w.getAttribute('lat'));
        const lon = parseFloat(w.getAttribute('lon'));
        let size = 2;
        const name = w.getElementsByTagName('name')[0];
        if (name && /size:\s*\d+/i.test(name.textContent)) {
          const m = name.textContent.match(/size:\s*(\d+)/i);
          if (m) size = parseFloat(m[1]);
        }
        addPin(lat, lon, size);
      }
    }

    // Initial mode
    applyMode('heat');
  </script>
</body>
</html>