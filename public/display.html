<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Leinwand (Zoom-stabil)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #map { height: 100%; }
    .controls {
      position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
      background: rgba(255,255,255,0.95); padding: 8px 10px; border-radius: 10px; z-index: 999;
      display: flex; gap: 10px; align-items: center; box-shadow: 0 2px 8px rgba(0,0,0,0.25);
      flex-wrap: wrap;
    }
    .badge { font-size: 12px; background:#eee; padding:2px 6px; border-radius:999px; }
    select, button { padding: 6px; }
    .export-group { display: inline-flex; gap: 6px; align-items: center; }
    @media (max-width: 700px) {
      .controls { gap: 8px; }
      .export-group select { max-width: 140px; }
    }
  </style>
</head>
<body>
  <div class="controls">
    <label>Basemap:
      <select id="basemap">
        <option value="positron" selected>CartoDB Positron</option>
        <option value="voyager">CartoDB Voyager</option>
        <option value="osmde">OSM DE</option>
        <option value="osmstd">OSM Standard</option>
        <option value="tonerlite">Stamen Toner Lite</option>
      </select>
    </label>
    Ansicht:
    <label><input type="radio" name="mode" value="heat" checked> Heatmap</label>
    <label><input type="radio" name="mode" value="cluster"> Cluster</label>
    <label><input type="radio" name="mode" value="both"> Beides</label>
    <span class="badge" id="count">0 Pins</span>
    <button id="fitBtn">Fit to Pins</button>
    <div class="export-group">
      <label for="exportSelect">Export:</label>
      <select id="exportSelect">
        <option value="geojson">GeoJSON (.geojson)</option>
        <option value="csv">CSV (.csv)</option>
        <option value="kml">KML (.kml)</option>
        <option value="gpx">GPX (.gpx)</option>
      </select>
      <button id="exportBtn">Download</button>
    </div>
    <button id="resetBtn">Reset</button>
  </div>
  <div id="map"></div>

  <script src="/socket.io/socket.io.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script>
    const socket = io();
    const map = L.map('map', { zoomControl: true }).setView([51.4566, 7.0123], 12);

    // Basemaps
    const basemaps = {
      positron: L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; OpenStreetMap & CARTO', subdomains: 'abcd', maxZoom: 20 }),
      voyager:  L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', { attribution: '&copy; OpenStreetMap & CARTO', subdomains: 'abcd', maxZoom: 20 }),
      osmde:    L.tileLayer('https://tile.openstreetmap.de/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap', maxZoom: 19 }),
      osmstd:   L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap', maxZoom: 19 }),
      tonerlite:L.tileLayer('https://stamen-tiles.a.ssl.fastly.net/toner-lite/{z}/{x}/{y}.png', { attribution: '&copy; Stamen & OpenStreetMap', maxZoom: 20 })
    };
    let currentBase = basemaps.positron.addTo(map);
    document.getElementById('basemap').addEventListener('change', (e) => {
      const val = e.target.value;
      if (basemaps[val]) { map.removeLayer(currentBase); currentBase = basemaps[val].addTo(map); }
    });

    // ---- Zoom-stable Heatmap ----
    // Base radius in meters (visual influence zone per pin in heat)
    const HEAT_RADIUS_METERS = 800;
    const HEAT_BLUR_RATIO = 0.6;
    const heat = L.heatLayer([], { radius: 25, blur: 15, maxZoom: 16, minOpacity: 0.3, max: 5 });

    function metersToPixels(m, lat, zoom) {
      const mpp = 156543.03392 * Math.cos(lat * Math.PI/180) / Math.pow(2, zoom);
      return m / mpp;
    }
    function updateHeatRadius() {
      const z = map.getZoom();
      const lat = map.getCenter().lat;
      const rPx = Math.max(5, Math.round(metersToPixels(HEAT_RADIUS_METERS, lat, z)));
      heat.setOptions({ radius: rPx, blur: Math.round(rPx * HEAT_BLUR_RATIO) });
    }

    // ---- Meter-based marker sizing (with cluster) ----
    const SIZE_TO_METERS = { 1: 150, 2: 300, 3: 600 }; // visual diameter per size
    function markerPxFor(p) {
      const lat = map.getCenter().lat;
      const z = map.getZoom();
      const meters = SIZE_TO_METERS[Math.max(1, Math.min(3, p.size||2))] || 300;
      const px = Math.round(metersToPixels(meters, lat, z));
      return Math.max(6, Math.min(px, 40)); // clamp to keep clusters readable
    }
    function pinToMarker(p) {
      const px = markerPxFor(p);
      return L.marker([p.lat, p.lon], {
        icon: L.divIcon({
          className: 'pin',
          html: '<div style="width:'+ px +'px;height:'+ px +'px;border-radius:50%;border:2px solid #ef4444;background:rgba(239,68,68,0.5)"></div>',
          iconSize: [px, px], iconAnchor: [px/2, px/2]
        })
      });
    }

    const clusters = L.markerClusterGroup({ showCoverageOnHover: false, maxClusterRadius: 60 });

    const pins = [];
    const countEl = document.getElementById('count');
    function updateCount() { countEl.textContent = pins.length + ' Pins'; }

    function renderAll() {
      // Heat
      heat.setLatLngs(pins.map(p => [p.lat, p.lon, Math.max(1, Math.min(5, p.size))]));
      // Clusters
      clusters.clearLayers();
      clusters.addLayers(pins.map(pinToMarker));
      applyMode(currentMode());
      updateCount();
      updateHeatRadius();
    }

    function addPin(p) {
      pins.push(p);
      heat.addLatLng([p.lat, p.lon, Math.max(1, Math.min(5, p.size))]);
      clusters.addLayer(pinToMarker(p));
      updateCount();
      updateHeatRadius();
    }

    function currentMode() { return document.querySelector('input[name="mode"]:checked').value; }
    function applyMode(mode) {
      map.removeLayer(heat);
      map.removeLayer(clusters);
      if (mode === 'heat') heat.addTo(map);
      else if (mode === 'cluster') clusters.addTo(map);
      else { heat.addTo(map); clusters.addTo(map); }
    }

    // Fit to Pins
    function fitToPins() {
      if (pins.length === 0) return;
      const latlngs = pins.map(p => [p.lat, p.lon]);
      map.fitBounds(latlngs, { padding: [40, 40] });
    }
    document.getElementById('fitBtn').addEventListener('click', fitToPins);

    // Export via dropdown
    document.getElementById('exportBtn').addEventListener('click', () => {
      const ext = document.getElementById('exportSelect').value;
      const href = ext === 'geojson' ? '/pins.geojson'
                 : ext === 'csv'     ? '/pins.csv'
                 : ext === 'kml'     ? '/pins.kml'
                 : '/pins.gpx';
      window.open(href, '_blank');
    });

    // Reset
    document.getElementById('resetBtn').addEventListener('click', () => {
      const pw = prompt('Reset-Passwort:');
      if (!pw) return;
      fetch('/reset', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ password: pw }) })
        .then(res => { if (!res.ok) alert('UngÃ¼ltiges Passwort!'); });
    });

    // Live data
    socket.on('init', (arr) => { arr.forEach(p => pins.push(p)); renderAll(); });
    socket.on('pinAdded', addPin);
    socket.on('reset', () => { pins.length = 0; heat.setLatLngs([]); clusters.clearLayers(); updateCount(); updateHeatRadius(); });

    document.querySelectorAll('input[name="mode"]').forEach(r => r.addEventListener('change', () => applyMode(currentMode())));
    applyMode('heat');

    // Recompute on zoom/move to keep visuals stable
    map.on('zoomend moveend', () => {
      updateHeatRadius();
      if (map.hasLayer(clusters)) {
        clusters.clearLayers();
        clusters.addLayers(pins.map(pinToMarker));
      }
    });
  </script>
</body>
</html>