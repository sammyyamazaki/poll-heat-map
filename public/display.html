<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Leinwand (Heatmap feinabgestimmt)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #map { height: 100%; }
    .controls {
      position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
      background: rgba(255,255,255,0.95); padding: 8px 10px; border-radius: 10px; z-index: 999;
      display: flex; gap: 10px; align-items: center; box-shadow: 0 2px 8px rgba(0,0,0,0.25);
      flex-wrap: wrap;
    }
    .badge { font-size: 12px; background:#eee; padding:2px 6px; border-radius:999px; }
    select, button, input[type="range"] { padding: 6px; }
    .export-group { display: inline-flex; gap: 6px; align-items: center; }
    .range-wrap { display: inline-flex; align-items: center; gap: 6px; }
    .range-wrap label { font-size: 12px; opacity: .8; }
    .range-wrap input { width: 120px; }
    @media (max-width: 700px) {
      .controls { gap: 8px; }
      .export-group select { max-width: 140px; }
    }
  </style>
</head>
<body>
  <div class="controls">
    <label>Basemap:
      <select id="basemap">
        <option value="positron" selected>CartoDB Positron</option>
        <option value="voyager">CartoDB Voyager</option>
        <option value="osmde">OSM DE</option>
        <option value="osmstd">OSM Standard</option>
        <option value="tonerlite">Stamen Toner Lite</option>
      </select>
    </label>
    Ansicht:
    <label><input type="radio" name="mode" value="heat" checked> Heatmap</label>
    <label><input type="radio" name="mode" value="cluster"> Cluster</label>
    <label><input type="radio" name="mode" value="both"> Beides</label>
    <div class="range-wrap">
      <label for="intensity">Intensität</label>
      <input id="intensity" type="range" min="0.5" max="2" value="1" step="0.1">
    </div>
    <span class="badge" id="count">0 Pins</span>
    <button id="fitBtn">Fit to Pins</button>
    <div class="export-group">
      <label for="exportSelect">Export:</label>
      <select id="exportSelect">
        <option value="geojson">GeoJSON (.geojson)</option>
        <option value="csv">CSV (.csv)</option>
        <option value="kml">KML (.kml)</option>
        <option value="gpx">GPX (.gpx)</option>
      </select>
      <button id="exportBtn">Download</button>
    </div>
    <button id="resetBtn">Reset</button>
  </div>
  <div id="map"></div>

  <script src="/socket.io/socket.io.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script>
    const socket = io();
    const map = L.map('map', { zoomControl: true }).setView([51.4566, 7.0123], 12);

    // Basemaps
    const basemaps = {
      positron: L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; OpenStreetMap & CARTO', subdomains: 'abcd', maxZoom: 20 }),
      voyager:  L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', { attribution: '&copy; OpenStreetMap & CARTO', subdomains: 'abcd', maxZoom: 20 }),
      osmde:    L.tileLayer('https://tile.openstreetmap.de/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap', maxZoom: 19 }),
      osmstd:   L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap', maxZoom: 19 }),
      tonerlite:L.tileLayer('https://stamen-tiles.a.ssl.fastly.net/toner-lite/{z}/{x}/{y}.png', { attribution: '&copy; Stamen & OpenStreetMap', maxZoom: 20 })
    };
    let currentBase = basemaps.positron.addTo(map);
    document.getElementById('basemap').addEventListener('change', (e) => {
      const val = e.target.value;
      if (basemaps[val]) { map.removeLayer(currentBase); currentBase = basemaps[val].addTo(map); }
    });

    // ---- Heatmap: meter-based radius with clamping + adjustable intensity ----
    const HEAT_BASE_METERS = 350;            // kleinerer Basisradius
    const HEAT_BLUR_RATIO = 0.7;
    const HEAT_MIN_PX = 15, HEAT_MAX_PX = 50; // harte Grenzen gegen Artefakte
    const sizeWeight = {1: 0.7, 2: 1.0, 3: 1.5};
    let intensityFactor = 1.0;

    const heat = L.heatLayer([], { radius: 25, blur: 15, maxZoom: 18, minOpacity: 0.25, max: 2 });

    function metersToPixels(m, lat, zoom) {
      const mpp = 156543.03392 * Math.cos(lat * Math.PI/180) / Math.pow(2, zoom);
      return m / mpp;
    }
    function updateHeatRadius() {
      const z = map.getZoom();
      const lat = map.getCenter().lat;
      let rPx = Math.round(metersToPixels(HEAT_BASE_METERS, lat, z));
      rPx = Math.max(HEAT_MIN_PX, Math.min(HEAT_MAX_PX, rPx));
      heat.setOptions({ radius: rPx, blur: Math.round(rPx * HEAT_BLUR_RATIO) });
    }
    function recomputeHeatPoints() {
      const pts = pins.map(p => [p.lat, p.lon, (sizeWeight[p.size] || 1) * intensityFactor]);
      heat.setLatLngs(pts);
    }

    // ---- Marker: zurück zu fixen Pixelgrößen (= bewährte Darstellung in Clustern) ----
    function pinToMarker(p) {
      const s = Math.max(1, Math.min(5, p.size || 2));
      const px = s * 6; // wie vorher
      return L.marker([p.lat, p.lon], {
        icon: L.divIcon({
          className: 'pin',
          html: '<div style="width:'+ px +'px;height:'+ px +'px;border-radius:50%;border:2px solid #ef4444;background:rgba(239,68,68,0.5)"></div>',
          iconSize: [px, px], iconAnchor: [px/2, px/2]
        })
      });
    }
    const clusters = L.markerClusterGroup({ showCoverageOnHover: false, maxClusterRadius: 60 });

    const pins = [];
    const countEl = document.getElementById('count');
    function updateCount() { countEl.textContent = pins.length + ' Pins'; }

    function renderAll() {
      recomputeHeatPoints();
      clusters.clearLayers();
      clusters.addLayers(pins.map(pinToMarker));
      applyMode(currentMode());
      updateCount();
      updateHeatRadius();
    }

    function addPin(p) {
      pins.push(p);
      recomputeHeatPoints();
      clusters.addLayer(pinToMarker(p));
      updateCount();
      updateHeatRadius();
    }

    function currentMode() { return document.querySelector('input[name="mode"]:checked').value; }
    function applyMode(mode) {
      map.removeLayer(heat);
      map.removeLayer(clusters);
      if (mode === 'heat') heat.addTo(map);
      else if (mode === 'cluster') clusters.addTo(map);
      else { heat.addTo(map); clusters.addTo(map); }
    }

    // Fit to Pins
    function fitToPins() {
      if (pins.length === 0) return;
      const latlngs = pins.map(p => [p.lat, p.lon]);
      map.fitBounds(latlngs, { padding: [40, 40] });
    }
    document.getElementById('fitBtn').addEventListener('click', fitToPins);

    // Export via dropdown
    document.getElementById('exportBtn').addEventListener('click', () => {
      const ext = document.getElementById('exportSelect').value;
      const href = ext === 'geojson' ? '/pins.geojson'
                 : ext === 'csv'     ? '/pins.csv'
                 : ext === 'kml'     ? '/pins.kml'
                 : '/pins.gpx';
      window.open(href, '_blank');
    });

    // Reset
    document.getElementById('resetBtn').addEventListener('click', () => {
      const pw = prompt('Reset-Passwort:');
      if (!pw) return;
      fetch('/reset', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ password: pw }) })
        .then(res => { if (!res.ok) alert('Ungültiges Passwort!'); });
    });

    // Live data
    socket.on('init', (arr) => { arr.forEach(p => pins.push(p)); renderAll(); });
    socket.on('pinAdded', addPin);
    socket.on('reset', () => { pins.length = 0; heat.setLatLngs([]); clusters.clearLayers(); updateCount(); updateHeatRadius(); });

    document.querySelectorAll('input[name="mode"]').forEach(r => r.addEventListener('change', () => applyMode(currentMode())));
    applyMode('heat');

    // Intensity slider
    document.getElementById('intensity').addEventListener('input', (e) => {
      intensityFactor = parseFloat(e.target.value || '1');
      recomputeHeatPoints();
    });

    // Keep visuals stable enough
    map.on('zoomend moveend', () => {
      updateHeatRadius();
    });
  </script>
</body>
</html>